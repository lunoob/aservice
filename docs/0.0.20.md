# Biteagle-Service

> 基于 axios

针对每个项目都需要用到的 http 服务进行封装，免去每次都得新建一大堆，并复制来复制去的麻烦。



## 安装

`npm`

```shell
npm install axios biteagle-service
```

`yarn`

```shell
yarn add axios biteagle-service
```

`pnpm`

```shell
pnpm add axios biteagle-service
```



需要同时安装 axios 和 biteagle-service，因为 biteagle-service 依赖于 axios



## 特性

1. 请求路径支持动态路径参数
2. 统一成功与错误的响应体
3. 函数柯里化
4. 支持 TypeScript



## API

- ### createRequest

  创建请求器对象，返回 axios 实例与一个请求方法

- ### carryParamsInterceptor

  创建携带额外的参数的请求拦截器

  ```typescript
  import { carryParamsInterceptor, createRequestInterceptor } from 'biteagle-service'
  
  createRequestInterceptor(carryParamsInterceptor({
    name: 'xxx',
    age: 18
  }))
  ```

  

- ### createRequestInterceptor

  全局注册请求拦截器

- ### createResponseInterceptor

  全局注册请求拦截器



## 使用

### 普通使用

1. ### 创建实例

   ```typescript
   import { createRequest } from 'biteagle-serivce'
   
   const http = createRequest({ baseURL: '/api' })
   ```

2. ### 发起请求

   ```typescript
   const params = {
     name: 'biteagle'
   }
   
   // 1. 方式一
   await http.request('get')('/data')(params)
   // 2. 方式二
   await http.request('get', '/data')(params)
   // 3. 方式三
   await http.request('get', '/data', params)
   ```

3. ### 接受数据

   ```typescript
   const result = await http.request('get')('/data')(params)
   
   // 返回的相应数据结构如下，无论是成功还是失败，统一都是这种以下结构
   interface result {
     status: number
     data: any
     message: string
   }
   ```

   

### 动态路径参数

当 url 路径上需要支持动态参数时

例如：/list/id，id 为动态时，可以写为 /list/:id

在发起请求时

```typescript
http.request('get', '/list/:id', {
  _id: 123,
  name: 'bitealge',
  age: 18
})
```

上述代码最终发起请求时的 url 路径实际为：/list/123

如果请求方法是 post、put 等时，携带的参数为

```typescript
{
  name: 'xxx',
  age: 18
}
```

如果请求方法是 get、delete 等时，携带的参数为

```typescript
?name=xxx&age=18

// 会拼接在 url 路径上
```



### 使用拦截器

提供了两个 API 去分别注册全局请求，响应拦截器

- 请求拦截器会在发出请求之前执行
- 响应拦截器会在进行数据结构统一之前执行



注意：必须要在创建请求器之前进行注册拦截器，否则不会注册成功

```typescript
import { createRequestInterceptor, createRequest } from 'biteagle-service'

// 一定要在创建请求器之前进行注册，才会生效
createRequestInterceptor((config) => {
  // do something before request is sent
	return config  
})

const http = createRequest({ ... })
```

传递的参数和 axios 文档上的一致，[文档](https://github.com/axios/axios#interceptors)



## 注意

在使用拦截器的时候。axios 本身与 axios 实例两个是独立的，并不会出现继承的情况.

假如现在在 axios 上注册了一个请求前的拦截器，随后实例化一个 axios 实例 A.

打印 A 的拦截器列表可以发现，并没有自动继承之前在 axios 本身注册的拦截器.